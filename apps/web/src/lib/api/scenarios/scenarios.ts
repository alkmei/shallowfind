/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Shallowfind
 * Shallowfind Financial Planner
 * OpenAPI spec version: 0.0.1
 */
import { createMutation, createQuery } from '@tanstack/svelte-query';
import type {
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey
} from '@tanstack/svelte-query';

import axios from 'axios';
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';

import type { PatchedScenario, Scenario } from '../shallowfind.schemas';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

/**
 * ViewSet for managing scenarios with full CRUD operations.
Provides list, create, retrieve, update, destroy actions.
 */
export const scenariosList = (options?: AxiosRequestConfig): Promise<AxiosResponse<Scenario[]>> => {
  return axios.get(`/api/scenarios/`, options);
};

export const getScenariosListQueryKey = () => {
  return [`/api/scenarios/`] as const;
};

export const getScenariosListQueryOptions = <
  TData = Awaited<ReturnType<typeof scenariosList>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof scenariosList>>, TError, TData>>;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getScenariosListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof scenariosList>>> = ({ signal }) =>
    scenariosList({ signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    useQuery: true,
    staleTime: 300000,
    ...queryOptions
  } as CreateQueryOptions<Awaited<ReturnType<typeof scenariosList>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type ScenariosListQueryResult = NonNullable<Awaited<ReturnType<typeof scenariosList>>>;
export type ScenariosListQueryError = AxiosError<unknown>;

export function createScenariosList<
  TData = Awaited<ReturnType<typeof scenariosList>>,
  TError = AxiosError<unknown>
>(
  options?: {
    query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof scenariosList>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getScenariosListQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ViewSet for managing scenarios with full CRUD operations.
Provides list, create, retrieve, update, destroy actions.
 */
export const scenariosCreate = (
  scenario: NonReadonly<Scenario>,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Scenario>> => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`id`, scenario.id.toString());
  formUrlEncoded.append(`name`, scenario.name);
  formUrlEncoded.append(`maritalStatus`, scenario.maritalStatus);
  formUrlEncoded.append(`userBirthYear`, scenario.userBirthYear.toString());
  if (scenario.spouseBirthYear !== undefined && scenario.spouseBirthYear !== null) {
    formUrlEncoded.append(`spouseBirthYear`, scenario.spouseBirthYear.toString());
  }
  formUrlEncoded.append(`userLifeExpectancy`, JSON.stringify(scenario.userLifeExpectancy));
  if (scenario.spouseLifeExpectancy !== undefined && scenario.spouseLifeExpectancy !== null) {
    formUrlEncoded.append(`spouseLifeExpectancy`, scenario.spouseLifeExpectancy);
  }
  formUrlEncoded.append(`inflationAssumption`, JSON.stringify(scenario.inflationAssumption));
  formUrlEncoded.append(`afterTaxContributionLimit`, scenario.afterTaxContributionLimit.toString());
  formUrlEncoded.append(`financialGoal`, scenario.financialGoal.toString());
  formUrlEncoded.append(`residenceState`, scenario.residenceState);
  if (scenario.rothConversionOpt !== undefined) {
    formUrlEncoded.append(`rothConversionOpt`, scenario.rothConversionOpt.toString());
  }
  if (scenario.rothConversionStart !== undefined && scenario.rothConversionStart !== null) {
    formUrlEncoded.append(`rothConversionStart`, scenario.rothConversionStart.toString());
  }
  if (scenario.rothConversionEnd !== undefined && scenario.rothConversionEnd !== null) {
    formUrlEncoded.append(`rothConversionEnd`, scenario.rothConversionEnd.toString());
  }
  scenario.investments.forEach((value) =>
    formUrlEncoded.append(`investments`, JSON.stringify(value))
  );
  scenario.eventSeries.forEach((value) =>
    formUrlEncoded.append(`eventSeries`, JSON.stringify(value))
  );
  scenario.spendingStrategyItems.forEach((value) =>
    formUrlEncoded.append(`spendingStrategyItems`, JSON.stringify(value))
  );
  scenario.expenseWithdrawalStrategyItems.forEach((value) =>
    formUrlEncoded.append(`expenseWithdrawalStrategyItems`, JSON.stringify(value))
  );
  scenario.rmdStrategyItems.forEach((value) =>
    formUrlEncoded.append(`rmdStrategyItems`, JSON.stringify(value))
  );
  scenario.rothConversionStrategyItems.forEach((value) =>
    formUrlEncoded.append(`rothConversionStrategyItems`, JSON.stringify(value))
  );
  formUrlEncoded.append(`createdAt`, scenario.createdAt);
  formUrlEncoded.append(`updatedAt`, scenario.updatedAt);
  if (scenario.spendingStrategyInput !== undefined) {
    scenario.spendingStrategyInput.forEach((value) =>
      formUrlEncoded.append(`spendingStrategyInput`, value)
    );
  }
  if (scenario.expenseWithdrawalStrategyInput !== undefined) {
    scenario.expenseWithdrawalStrategyInput.forEach((value) =>
      formUrlEncoded.append(`expenseWithdrawalStrategyInput`, value)
    );
  }
  if (scenario.rmdStrategyInput !== undefined) {
    scenario.rmdStrategyInput.forEach((value) => formUrlEncoded.append(`rmdStrategyInput`, value));
  }
  if (scenario.rothConversionStrategyInput !== undefined) {
    scenario.rothConversionStrategyInput.forEach((value) =>
      formUrlEncoded.append(`rothConversionStrategyInput`, value)
    );
  }

  return axios.post(`/api/scenarios/`, formUrlEncoded, options);
};

export const getScenariosCreateMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof scenariosCreate>>,
    TError,
    { data: NonReadonly<Scenario> },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof scenariosCreate>>,
  TError,
  { data: NonReadonly<Scenario> },
  TContext
> => {
  const mutationKey = ['scenariosCreate'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scenariosCreate>>,
    { data: NonReadonly<Scenario> }
  > = (props) => {
    const { data } = props ?? {};

    return scenariosCreate(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScenariosCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof scenariosCreate>>
>;
export type ScenariosCreateMutationBody = NonReadonly<Scenario>;
export type ScenariosCreateMutationError = AxiosError<unknown>;

export const createScenariosCreate = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof scenariosCreate>>,
      TError,
      { data: NonReadonly<Scenario> },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof scenariosCreate>>,
  TError,
  { data: NonReadonly<Scenario> },
  TContext
> => {
  const mutationOptions = getScenariosCreateMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * ViewSet for managing scenarios with full CRUD operations.
Provides list, create, retrieve, update, destroy actions.
 */
export const scenariosRetrieve = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Scenario>> => {
  return axios.get(`/api/scenarios/${id}/`, options);
};

export const getScenariosRetrieveQueryKey = (id: number) => {
  return [`/api/scenarios/${id}/`] as const;
};

export const getScenariosRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof scenariosRetrieve>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof scenariosRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getScenariosRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof scenariosRetrieve>>> = ({ signal }) =>
    scenariosRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    useQuery: true,
    staleTime: 300000,
    ...queryOptions
  } as CreateQueryOptions<Awaited<ReturnType<typeof scenariosRetrieve>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type ScenariosRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof scenariosRetrieve>>
>;
export type ScenariosRetrieveQueryError = AxiosError<unknown>;

export function createScenariosRetrieve<
  TData = Awaited<ReturnType<typeof scenariosRetrieve>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof scenariosRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getScenariosRetrieveQueryOptions(id, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ViewSet for managing scenarios with full CRUD operations.
Provides list, create, retrieve, update, destroy actions.
 */
export const scenariosUpdate = (
  id: number,
  scenario: NonReadonly<Scenario>,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Scenario>> => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`id`, scenario.id.toString());
  formUrlEncoded.append(`name`, scenario.name);
  formUrlEncoded.append(`maritalStatus`, scenario.maritalStatus);
  formUrlEncoded.append(`userBirthYear`, scenario.userBirthYear.toString());
  if (scenario.spouseBirthYear !== undefined && scenario.spouseBirthYear !== null) {
    formUrlEncoded.append(`spouseBirthYear`, scenario.spouseBirthYear.toString());
  }
  formUrlEncoded.append(`userLifeExpectancy`, JSON.stringify(scenario.userLifeExpectancy));
  if (scenario.spouseLifeExpectancy !== undefined && scenario.spouseLifeExpectancy !== null) {
    formUrlEncoded.append(`spouseLifeExpectancy`, scenario.spouseLifeExpectancy);
  }
  formUrlEncoded.append(`inflationAssumption`, JSON.stringify(scenario.inflationAssumption));
  formUrlEncoded.append(`afterTaxContributionLimit`, scenario.afterTaxContributionLimit.toString());
  formUrlEncoded.append(`financialGoal`, scenario.financialGoal.toString());
  formUrlEncoded.append(`residenceState`, scenario.residenceState);
  if (scenario.rothConversionOpt !== undefined) {
    formUrlEncoded.append(`rothConversionOpt`, scenario.rothConversionOpt.toString());
  }
  if (scenario.rothConversionStart !== undefined && scenario.rothConversionStart !== null) {
    formUrlEncoded.append(`rothConversionStart`, scenario.rothConversionStart.toString());
  }
  if (scenario.rothConversionEnd !== undefined && scenario.rothConversionEnd !== null) {
    formUrlEncoded.append(`rothConversionEnd`, scenario.rothConversionEnd.toString());
  }
  scenario.investments.forEach((value) =>
    formUrlEncoded.append(`investments`, JSON.stringify(value))
  );
  scenario.eventSeries.forEach((value) =>
    formUrlEncoded.append(`eventSeries`, JSON.stringify(value))
  );
  scenario.spendingStrategyItems.forEach((value) =>
    formUrlEncoded.append(`spendingStrategyItems`, JSON.stringify(value))
  );
  scenario.expenseWithdrawalStrategyItems.forEach((value) =>
    formUrlEncoded.append(`expenseWithdrawalStrategyItems`, JSON.stringify(value))
  );
  scenario.rmdStrategyItems.forEach((value) =>
    formUrlEncoded.append(`rmdStrategyItems`, JSON.stringify(value))
  );
  scenario.rothConversionStrategyItems.forEach((value) =>
    formUrlEncoded.append(`rothConversionStrategyItems`, JSON.stringify(value))
  );
  formUrlEncoded.append(`createdAt`, scenario.createdAt);
  formUrlEncoded.append(`updatedAt`, scenario.updatedAt);
  if (scenario.spendingStrategyInput !== undefined) {
    scenario.spendingStrategyInput.forEach((value) =>
      formUrlEncoded.append(`spendingStrategyInput`, value)
    );
  }
  if (scenario.expenseWithdrawalStrategyInput !== undefined) {
    scenario.expenseWithdrawalStrategyInput.forEach((value) =>
      formUrlEncoded.append(`expenseWithdrawalStrategyInput`, value)
    );
  }
  if (scenario.rmdStrategyInput !== undefined) {
    scenario.rmdStrategyInput.forEach((value) => formUrlEncoded.append(`rmdStrategyInput`, value));
  }
  if (scenario.rothConversionStrategyInput !== undefined) {
    scenario.rothConversionStrategyInput.forEach((value) =>
      formUrlEncoded.append(`rothConversionStrategyInput`, value)
    );
  }

  return axios.put(`/api/scenarios/${id}/`, formUrlEncoded, options);
};

export const getScenariosUpdateMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof scenariosUpdate>>,
    TError,
    { id: number; data: NonReadonly<Scenario> },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof scenariosUpdate>>,
  TError,
  { id: number; data: NonReadonly<Scenario> },
  TContext
> => {
  const mutationKey = ['scenariosUpdate'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scenariosUpdate>>,
    { id: number; data: NonReadonly<Scenario> }
  > = (props) => {
    const { id, data } = props ?? {};

    return scenariosUpdate(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScenariosUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof scenariosUpdate>>
>;
export type ScenariosUpdateMutationBody = NonReadonly<Scenario>;
export type ScenariosUpdateMutationError = AxiosError<unknown>;

export const createScenariosUpdate = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof scenariosUpdate>>,
      TError,
      { id: number; data: NonReadonly<Scenario> },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof scenariosUpdate>>,
  TError,
  { id: number; data: NonReadonly<Scenario> },
  TContext
> => {
  const mutationOptions = getScenariosUpdateMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * ViewSet for managing scenarios with full CRUD operations.
Provides list, create, retrieve, update, destroy actions.
 */
export const scenariosPartialUpdate = (
  id: number,
  patchedScenario: NonReadonly<PatchedScenario>,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Scenario>> => {
  const formUrlEncoded = new URLSearchParams();
  if (patchedScenario.id !== undefined) {
    formUrlEncoded.append(`id`, patchedScenario.id.toString());
  }
  if (patchedScenario.name !== undefined) {
    formUrlEncoded.append(`name`, patchedScenario.name);
  }
  if (patchedScenario.maritalStatus !== undefined) {
    formUrlEncoded.append(`maritalStatus`, patchedScenario.maritalStatus);
  }
  if (patchedScenario.userBirthYear !== undefined) {
    formUrlEncoded.append(`userBirthYear`, patchedScenario.userBirthYear.toString());
  }
  if (patchedScenario.spouseBirthYear !== undefined && patchedScenario.spouseBirthYear !== null) {
    formUrlEncoded.append(`spouseBirthYear`, patchedScenario.spouseBirthYear.toString());
  }
  if (patchedScenario.userLifeExpectancy !== undefined) {
    formUrlEncoded.append(`userLifeExpectancy`, JSON.stringify(patchedScenario.userLifeExpectancy));
  }
  if (
    patchedScenario.spouseLifeExpectancy !== undefined &&
    patchedScenario.spouseLifeExpectancy !== null
  ) {
    formUrlEncoded.append(`spouseLifeExpectancy`, patchedScenario.spouseLifeExpectancy);
  }
  if (patchedScenario.inflationAssumption !== undefined) {
    formUrlEncoded.append(
      `inflationAssumption`,
      JSON.stringify(patchedScenario.inflationAssumption)
    );
  }
  if (patchedScenario.afterTaxContributionLimit !== undefined) {
    formUrlEncoded.append(
      `afterTaxContributionLimit`,
      patchedScenario.afterTaxContributionLimit.toString()
    );
  }
  if (patchedScenario.financialGoal !== undefined) {
    formUrlEncoded.append(`financialGoal`, patchedScenario.financialGoal.toString());
  }
  if (patchedScenario.residenceState !== undefined) {
    formUrlEncoded.append(`residenceState`, patchedScenario.residenceState);
  }
  if (patchedScenario.rothConversionOpt !== undefined) {
    formUrlEncoded.append(`rothConversionOpt`, patchedScenario.rothConversionOpt.toString());
  }
  if (
    patchedScenario.rothConversionStart !== undefined &&
    patchedScenario.rothConversionStart !== null
  ) {
    formUrlEncoded.append(`rothConversionStart`, patchedScenario.rothConversionStart.toString());
  }
  if (
    patchedScenario.rothConversionEnd !== undefined &&
    patchedScenario.rothConversionEnd !== null
  ) {
    formUrlEncoded.append(`rothConversionEnd`, patchedScenario.rothConversionEnd.toString());
  }
  if (patchedScenario.investments !== undefined) {
    patchedScenario.investments.forEach((value) =>
      formUrlEncoded.append(`investments`, JSON.stringify(value))
    );
  }
  if (patchedScenario.eventSeries !== undefined) {
    patchedScenario.eventSeries.forEach((value) =>
      formUrlEncoded.append(`eventSeries`, JSON.stringify(value))
    );
  }
  if (patchedScenario.spendingStrategyItems !== undefined) {
    patchedScenario.spendingStrategyItems.forEach((value) =>
      formUrlEncoded.append(`spendingStrategyItems`, JSON.stringify(value))
    );
  }
  if (patchedScenario.expenseWithdrawalStrategyItems !== undefined) {
    patchedScenario.expenseWithdrawalStrategyItems.forEach((value) =>
      formUrlEncoded.append(`expenseWithdrawalStrategyItems`, JSON.stringify(value))
    );
  }
  if (patchedScenario.rmdStrategyItems !== undefined) {
    patchedScenario.rmdStrategyItems.forEach((value) =>
      formUrlEncoded.append(`rmdStrategyItems`, JSON.stringify(value))
    );
  }
  if (patchedScenario.rothConversionStrategyItems !== undefined) {
    patchedScenario.rothConversionStrategyItems.forEach((value) =>
      formUrlEncoded.append(`rothConversionStrategyItems`, JSON.stringify(value))
    );
  }
  if (patchedScenario.createdAt !== undefined) {
    formUrlEncoded.append(`createdAt`, patchedScenario.createdAt);
  }
  if (patchedScenario.updatedAt !== undefined) {
    formUrlEncoded.append(`updatedAt`, patchedScenario.updatedAt);
  }
  if (patchedScenario.spendingStrategyInput !== undefined) {
    patchedScenario.spendingStrategyInput.forEach((value) =>
      formUrlEncoded.append(`spendingStrategyInput`, value)
    );
  }
  if (patchedScenario.expenseWithdrawalStrategyInput !== undefined) {
    patchedScenario.expenseWithdrawalStrategyInput.forEach((value) =>
      formUrlEncoded.append(`expenseWithdrawalStrategyInput`, value)
    );
  }
  if (patchedScenario.rmdStrategyInput !== undefined) {
    patchedScenario.rmdStrategyInput.forEach((value) =>
      formUrlEncoded.append(`rmdStrategyInput`, value)
    );
  }
  if (patchedScenario.rothConversionStrategyInput !== undefined) {
    patchedScenario.rothConversionStrategyInput.forEach((value) =>
      formUrlEncoded.append(`rothConversionStrategyInput`, value)
    );
  }

  return axios.patch(`/api/scenarios/${id}/`, formUrlEncoded, options);
};

export const getScenariosPartialUpdateMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof scenariosPartialUpdate>>,
    TError,
    { id: number; data: NonReadonly<PatchedScenario> },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof scenariosPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedScenario> },
  TContext
> => {
  const mutationKey = ['scenariosPartialUpdate'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scenariosPartialUpdate>>,
    { id: number; data: NonReadonly<PatchedScenario> }
  > = (props) => {
    const { id, data } = props ?? {};

    return scenariosPartialUpdate(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScenariosPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof scenariosPartialUpdate>>
>;
export type ScenariosPartialUpdateMutationBody = NonReadonly<PatchedScenario>;
export type ScenariosPartialUpdateMutationError = AxiosError<unknown>;

export const createScenariosPartialUpdate = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof scenariosPartialUpdate>>,
      TError,
      { id: number; data: NonReadonly<PatchedScenario> },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof scenariosPartialUpdate>>,
  TError,
  { id: number; data: NonReadonly<PatchedScenario> },
  TContext
> => {
  const mutationOptions = getScenariosPartialUpdateMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * ViewSet for managing scenarios with full CRUD operations.
Provides list, create, retrieve, update, destroy actions.
 */
export const scenariosDestroy = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.delete(`/api/scenarios/${id}/`, options);
};

export const getScenariosDestroyMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof scenariosDestroy>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof scenariosDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ['scenariosDestroy'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scenariosDestroy>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return scenariosDestroy(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScenariosDestroyMutationResult = NonNullable<
  Awaited<ReturnType<typeof scenariosDestroy>>
>;

export type ScenariosDestroyMutationError = AxiosError<unknown>;

export const createScenariosDestroy = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof scenariosDestroy>>,
      TError,
      { id: number },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof scenariosDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getScenariosDestroyMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * Clone an existing scenario
 */
export const scenariosCloneCreate = (
  id: number,
  scenario: NonReadonly<Scenario>,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Scenario>> => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`id`, scenario.id.toString());
  formUrlEncoded.append(`name`, scenario.name);
  formUrlEncoded.append(`maritalStatus`, scenario.maritalStatus);
  formUrlEncoded.append(`userBirthYear`, scenario.userBirthYear.toString());
  if (scenario.spouseBirthYear !== undefined && scenario.spouseBirthYear !== null) {
    formUrlEncoded.append(`spouseBirthYear`, scenario.spouseBirthYear.toString());
  }
  formUrlEncoded.append(`userLifeExpectancy`, JSON.stringify(scenario.userLifeExpectancy));
  if (scenario.spouseLifeExpectancy !== undefined && scenario.spouseLifeExpectancy !== null) {
    formUrlEncoded.append(`spouseLifeExpectancy`, scenario.spouseLifeExpectancy);
  }
  formUrlEncoded.append(`inflationAssumption`, JSON.stringify(scenario.inflationAssumption));
  formUrlEncoded.append(`afterTaxContributionLimit`, scenario.afterTaxContributionLimit.toString());
  formUrlEncoded.append(`financialGoal`, scenario.financialGoal.toString());
  formUrlEncoded.append(`residenceState`, scenario.residenceState);
  if (scenario.rothConversionOpt !== undefined) {
    formUrlEncoded.append(`rothConversionOpt`, scenario.rothConversionOpt.toString());
  }
  if (scenario.rothConversionStart !== undefined && scenario.rothConversionStart !== null) {
    formUrlEncoded.append(`rothConversionStart`, scenario.rothConversionStart.toString());
  }
  if (scenario.rothConversionEnd !== undefined && scenario.rothConversionEnd !== null) {
    formUrlEncoded.append(`rothConversionEnd`, scenario.rothConversionEnd.toString());
  }
  scenario.investments.forEach((value) =>
    formUrlEncoded.append(`investments`, JSON.stringify(value))
  );
  scenario.eventSeries.forEach((value) =>
    formUrlEncoded.append(`eventSeries`, JSON.stringify(value))
  );
  scenario.spendingStrategyItems.forEach((value) =>
    formUrlEncoded.append(`spendingStrategyItems`, JSON.stringify(value))
  );
  scenario.expenseWithdrawalStrategyItems.forEach((value) =>
    formUrlEncoded.append(`expenseWithdrawalStrategyItems`, JSON.stringify(value))
  );
  scenario.rmdStrategyItems.forEach((value) =>
    formUrlEncoded.append(`rmdStrategyItems`, JSON.stringify(value))
  );
  scenario.rothConversionStrategyItems.forEach((value) =>
    formUrlEncoded.append(`rothConversionStrategyItems`, JSON.stringify(value))
  );
  formUrlEncoded.append(`createdAt`, scenario.createdAt);
  formUrlEncoded.append(`updatedAt`, scenario.updatedAt);
  if (scenario.spendingStrategyInput !== undefined) {
    scenario.spendingStrategyInput.forEach((value) =>
      formUrlEncoded.append(`spendingStrategyInput`, value)
    );
  }
  if (scenario.expenseWithdrawalStrategyInput !== undefined) {
    scenario.expenseWithdrawalStrategyInput.forEach((value) =>
      formUrlEncoded.append(`expenseWithdrawalStrategyInput`, value)
    );
  }
  if (scenario.rmdStrategyInput !== undefined) {
    scenario.rmdStrategyInput.forEach((value) => formUrlEncoded.append(`rmdStrategyInput`, value));
  }
  if (scenario.rothConversionStrategyInput !== undefined) {
    scenario.rothConversionStrategyInput.forEach((value) =>
      formUrlEncoded.append(`rothConversionStrategyInput`, value)
    );
  }

  return axios.post(`/api/scenarios/${id}/clone/`, formUrlEncoded, options);
};

export const getScenariosCloneCreateMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof scenariosCloneCreate>>,
    TError,
    { id: number; data: NonReadonly<Scenario> },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof scenariosCloneCreate>>,
  TError,
  { id: number; data: NonReadonly<Scenario> },
  TContext
> => {
  const mutationKey = ['scenariosCloneCreate'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scenariosCloneCreate>>,
    { id: number; data: NonReadonly<Scenario> }
  > = (props) => {
    const { id, data } = props ?? {};

    return scenariosCloneCreate(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScenariosCloneCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof scenariosCloneCreate>>
>;
export type ScenariosCloneCreateMutationBody = NonReadonly<Scenario>;
export type ScenariosCloneCreateMutationError = AxiosError<unknown>;

export const createScenariosCloneCreate = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof scenariosCloneCreate>>,
      TError,
      { id: number; data: NonReadonly<Scenario> },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof scenariosCloneCreate>>,
  TError,
  { id: number; data: NonReadonly<Scenario> },
  TContext
> => {
  const mutationOptions = getScenariosCloneCreateMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * Export scenario as YAML
 */
export const scenariosExportRetrieve = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Scenario>> => {
  return axios.get(`/api/scenarios/${id}/export/`, options);
};

export const getScenariosExportRetrieveQueryKey = (id: number) => {
  return [`/api/scenarios/${id}/export/`] as const;
};

export const getScenariosExportRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof scenariosExportRetrieve>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof scenariosExportRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getScenariosExportRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof scenariosExportRetrieve>>> = ({
    signal
  }) => scenariosExportRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    useQuery: true,
    staleTime: 300000,
    ...queryOptions
  } as CreateQueryOptions<Awaited<ReturnType<typeof scenariosExportRetrieve>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type ScenariosExportRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof scenariosExportRetrieve>>
>;
export type ScenariosExportRetrieveQueryError = AxiosError<unknown>;

export function createScenariosExportRetrieve<
  TData = Awaited<ReturnType<typeof scenariosExportRetrieve>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: Partial<
      CreateQueryOptions<Awaited<ReturnType<typeof scenariosExportRetrieve>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getScenariosExportRetrieveQueryOptions(id, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Run Monte Carlo simulations for this scenario
 */
export const scenariosSimulateCreate = (
  id: number,
  scenario: NonReadonly<Scenario>,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Scenario>> => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`id`, scenario.id.toString());
  formUrlEncoded.append(`name`, scenario.name);
  formUrlEncoded.append(`maritalStatus`, scenario.maritalStatus);
  formUrlEncoded.append(`userBirthYear`, scenario.userBirthYear.toString());
  if (scenario.spouseBirthYear !== undefined && scenario.spouseBirthYear !== null) {
    formUrlEncoded.append(`spouseBirthYear`, scenario.spouseBirthYear.toString());
  }
  formUrlEncoded.append(`userLifeExpectancy`, JSON.stringify(scenario.userLifeExpectancy));
  if (scenario.spouseLifeExpectancy !== undefined && scenario.spouseLifeExpectancy !== null) {
    formUrlEncoded.append(`spouseLifeExpectancy`, scenario.spouseLifeExpectancy);
  }
  formUrlEncoded.append(`inflationAssumption`, JSON.stringify(scenario.inflationAssumption));
  formUrlEncoded.append(`afterTaxContributionLimit`, scenario.afterTaxContributionLimit.toString());
  formUrlEncoded.append(`financialGoal`, scenario.financialGoal.toString());
  formUrlEncoded.append(`residenceState`, scenario.residenceState);
  if (scenario.rothConversionOpt !== undefined) {
    formUrlEncoded.append(`rothConversionOpt`, scenario.rothConversionOpt.toString());
  }
  if (scenario.rothConversionStart !== undefined && scenario.rothConversionStart !== null) {
    formUrlEncoded.append(`rothConversionStart`, scenario.rothConversionStart.toString());
  }
  if (scenario.rothConversionEnd !== undefined && scenario.rothConversionEnd !== null) {
    formUrlEncoded.append(`rothConversionEnd`, scenario.rothConversionEnd.toString());
  }
  scenario.investments.forEach((value) =>
    formUrlEncoded.append(`investments`, JSON.stringify(value))
  );
  scenario.eventSeries.forEach((value) =>
    formUrlEncoded.append(`eventSeries`, JSON.stringify(value))
  );
  scenario.spendingStrategyItems.forEach((value) =>
    formUrlEncoded.append(`spendingStrategyItems`, JSON.stringify(value))
  );
  scenario.expenseWithdrawalStrategyItems.forEach((value) =>
    formUrlEncoded.append(`expenseWithdrawalStrategyItems`, JSON.stringify(value))
  );
  scenario.rmdStrategyItems.forEach((value) =>
    formUrlEncoded.append(`rmdStrategyItems`, JSON.stringify(value))
  );
  scenario.rothConversionStrategyItems.forEach((value) =>
    formUrlEncoded.append(`rothConversionStrategyItems`, JSON.stringify(value))
  );
  formUrlEncoded.append(`createdAt`, scenario.createdAt);
  formUrlEncoded.append(`updatedAt`, scenario.updatedAt);
  if (scenario.spendingStrategyInput !== undefined) {
    scenario.spendingStrategyInput.forEach((value) =>
      formUrlEncoded.append(`spendingStrategyInput`, value)
    );
  }
  if (scenario.expenseWithdrawalStrategyInput !== undefined) {
    scenario.expenseWithdrawalStrategyInput.forEach((value) =>
      formUrlEncoded.append(`expenseWithdrawalStrategyInput`, value)
    );
  }
  if (scenario.rmdStrategyInput !== undefined) {
    scenario.rmdStrategyInput.forEach((value) => formUrlEncoded.append(`rmdStrategyInput`, value));
  }
  if (scenario.rothConversionStrategyInput !== undefined) {
    scenario.rothConversionStrategyInput.forEach((value) =>
      formUrlEncoded.append(`rothConversionStrategyInput`, value)
    );
  }

  return axios.post(`/api/scenarios/${id}/simulate/`, formUrlEncoded, options);
};

export const getScenariosSimulateCreateMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof scenariosSimulateCreate>>,
    TError,
    { id: number; data: NonReadonly<Scenario> },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof scenariosSimulateCreate>>,
  TError,
  { id: number; data: NonReadonly<Scenario> },
  TContext
> => {
  const mutationKey = ['scenariosSimulateCreate'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scenariosSimulateCreate>>,
    { id: number; data: NonReadonly<Scenario> }
  > = (props) => {
    const { id, data } = props ?? {};

    return scenariosSimulateCreate(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScenariosSimulateCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof scenariosSimulateCreate>>
>;
export type ScenariosSimulateCreateMutationBody = NonReadonly<Scenario>;
export type ScenariosSimulateCreateMutationError = AxiosError<unknown>;

export const createScenariosSimulateCreate = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof scenariosSimulateCreate>>,
      TError,
      { id: number; data: NonReadonly<Scenario> },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof scenariosSimulateCreate>>,
  TError,
  { id: number; data: NonReadonly<Scenario> },
  TContext
> => {
  const mutationOptions = getScenariosSimulateCreateMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * Validate scenario for simulation readiness
 */
export const scenariosValidateScenarioRetrieve = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Scenario>> => {
  return axios.get(`/api/scenarios/${id}/validate_scenario/`, options);
};

export const getScenariosValidateScenarioRetrieveQueryKey = (id: number) => {
  return [`/api/scenarios/${id}/validate_scenario/`] as const;
};

export const getScenariosValidateScenarioRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof scenariosValidateScenarioRetrieve>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof scenariosValidateScenarioRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getScenariosValidateScenarioRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof scenariosValidateScenarioRetrieve>>> = ({
    signal
  }) => scenariosValidateScenarioRetrieve(id, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    useQuery: true,
    staleTime: 300000,
    ...queryOptions
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof scenariosValidateScenarioRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ScenariosValidateScenarioRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof scenariosValidateScenarioRetrieve>>
>;
export type ScenariosValidateScenarioRetrieveQueryError = AxiosError<unknown>;

export function createScenariosValidateScenarioRetrieve<
  TData = Awaited<ReturnType<typeof scenariosValidateScenarioRetrieve>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof scenariosValidateScenarioRetrieve>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getScenariosValidateScenarioRetrieveQueryOptions(id, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Import scenario from YAML file
 */
export const scenariosImportScenarioCreate = (
  scenario: NonReadonly<Scenario>,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Scenario>> => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`id`, scenario.id.toString());
  formUrlEncoded.append(`name`, scenario.name);
  formUrlEncoded.append(`maritalStatus`, scenario.maritalStatus);
  formUrlEncoded.append(`userBirthYear`, scenario.userBirthYear.toString());
  if (scenario.spouseBirthYear !== undefined && scenario.spouseBirthYear !== null) {
    formUrlEncoded.append(`spouseBirthYear`, scenario.spouseBirthYear.toString());
  }
  formUrlEncoded.append(`userLifeExpectancy`, JSON.stringify(scenario.userLifeExpectancy));
  if (scenario.spouseLifeExpectancy !== undefined && scenario.spouseLifeExpectancy !== null) {
    formUrlEncoded.append(`spouseLifeExpectancy`, scenario.spouseLifeExpectancy);
  }
  formUrlEncoded.append(`inflationAssumption`, JSON.stringify(scenario.inflationAssumption));
  formUrlEncoded.append(`afterTaxContributionLimit`, scenario.afterTaxContributionLimit.toString());
  formUrlEncoded.append(`financialGoal`, scenario.financialGoal.toString());
  formUrlEncoded.append(`residenceState`, scenario.residenceState);
  if (scenario.rothConversionOpt !== undefined) {
    formUrlEncoded.append(`rothConversionOpt`, scenario.rothConversionOpt.toString());
  }
  if (scenario.rothConversionStart !== undefined && scenario.rothConversionStart !== null) {
    formUrlEncoded.append(`rothConversionStart`, scenario.rothConversionStart.toString());
  }
  if (scenario.rothConversionEnd !== undefined && scenario.rothConversionEnd !== null) {
    formUrlEncoded.append(`rothConversionEnd`, scenario.rothConversionEnd.toString());
  }
  scenario.investments.forEach((value) =>
    formUrlEncoded.append(`investments`, JSON.stringify(value))
  );
  scenario.eventSeries.forEach((value) =>
    formUrlEncoded.append(`eventSeries`, JSON.stringify(value))
  );
  scenario.spendingStrategyItems.forEach((value) =>
    formUrlEncoded.append(`spendingStrategyItems`, JSON.stringify(value))
  );
  scenario.expenseWithdrawalStrategyItems.forEach((value) =>
    formUrlEncoded.append(`expenseWithdrawalStrategyItems`, JSON.stringify(value))
  );
  scenario.rmdStrategyItems.forEach((value) =>
    formUrlEncoded.append(`rmdStrategyItems`, JSON.stringify(value))
  );
  scenario.rothConversionStrategyItems.forEach((value) =>
    formUrlEncoded.append(`rothConversionStrategyItems`, JSON.stringify(value))
  );
  formUrlEncoded.append(`createdAt`, scenario.createdAt);
  formUrlEncoded.append(`updatedAt`, scenario.updatedAt);
  if (scenario.spendingStrategyInput !== undefined) {
    scenario.spendingStrategyInput.forEach((value) =>
      formUrlEncoded.append(`spendingStrategyInput`, value)
    );
  }
  if (scenario.expenseWithdrawalStrategyInput !== undefined) {
    scenario.expenseWithdrawalStrategyInput.forEach((value) =>
      formUrlEncoded.append(`expenseWithdrawalStrategyInput`, value)
    );
  }
  if (scenario.rmdStrategyInput !== undefined) {
    scenario.rmdStrategyInput.forEach((value) => formUrlEncoded.append(`rmdStrategyInput`, value));
  }
  if (scenario.rothConversionStrategyInput !== undefined) {
    scenario.rothConversionStrategyInput.forEach((value) =>
      formUrlEncoded.append(`rothConversionStrategyInput`, value)
    );
  }

  return axios.post(`/api/scenarios/import_scenario/`, formUrlEncoded, options);
};

export const getScenariosImportScenarioCreateMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof scenariosImportScenarioCreate>>,
    TError,
    { data: NonReadonly<Scenario> },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof scenariosImportScenarioCreate>>,
  TError,
  { data: NonReadonly<Scenario> },
  TContext
> => {
  const mutationKey = ['scenariosImportScenarioCreate'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof scenariosImportScenarioCreate>>,
    { data: NonReadonly<Scenario> }
  > = (props) => {
    const { data } = props ?? {};

    return scenariosImportScenarioCreate(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ScenariosImportScenarioCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof scenariosImportScenarioCreate>>
>;
export type ScenariosImportScenarioCreateMutationBody = NonReadonly<Scenario>;
export type ScenariosImportScenarioCreateMutationError = AxiosError<unknown>;

export const createScenariosImportScenarioCreate = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof scenariosImportScenarioCreate>>,
      TError,
      { data: NonReadonly<Scenario> },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient
): CreateMutationResult<
  Awaited<ReturnType<typeof scenariosImportScenarioCreate>>,
  TError,
  { data: NonReadonly<Scenario> },
  TContext
> => {
  const mutationOptions = getScenariosImportScenarioCreateMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
